{"ast":null,"code":"import axios from 'axios';\nimport { EventBus } from '@/utils/eventBus';\nexport default {\n  name: 'MemoryManagement',\n  data() {\n    return {\n      totalMemory: 1024,\n      // 总内存大小（MB）\n      usedMemory: 0,\n      freeMemory: 1024,\n      blockSize: 4,\n      // 每个块的大小（MB）\n      memoryRows: [],\n      blocksPerRow: 16\n    };\n  },\n  computed: {\n    memoryUsagePercentage() {\n      return Math.round(this.usedMemory / this.totalMemory * 100);\n    },\n    memoryUsageColor() {\n      const percentage = this.memoryUsagePercentage;\n      if (percentage < 60) return '#67C23A';\n      if (percentage < 80) return '#E6A23C';\n      return '#F56C6C';\n    }\n  },\n  created() {\n    this.initializeMemory();\n    // 监听进程状态变化事件\n    EventBus.$on('process-state-changed', this.updateMemoryState);\n  },\n  beforeDestroy() {\n    // 移除事件监听\n    EventBus.$off('process-state-changed', this.updateMemoryState);\n  },\n  methods: {\n    async initializeMemory() {\n      try {\n        await this.fetchMemoryStatus();\n        await this.fetchMemoryUsage();\n        await this.fetchFreeMemory();\n      } catch (error) {\n        console.error('初始化内存数据失败:', error);\n      }\n    },\n    async updateMemoryState() {\n      try {\n        await this.fetchMemoryStatus();\n        await this.fetchMemoryUsage();\n        await this.fetchFreeMemory();\n      } catch (error) {\n        console.error('更新内存状态失败:', error);\n      }\n    },\n    async fetchMemoryStatus() {\n      try {\n        const response = await axios.get('/memory/status');\n        const memoryStatus = response.data;\n        this.updateMemoryBlocks(memoryStatus);\n      } catch (error) {\n        console.error('获取内存状态失败:', error);\n      }\n    },\n    async fetchMemoryUsage() {\n      try {\n        const response = await axios.get('/memory/usage');\n        const usage = response.data;\n        this.usedMemory = Math.round(this.totalMemory * usage);\n        this.freeMemory = this.totalMemory - this.usedMemory;\n      } catch (error) {\n        console.error('获取内存使用率失败:', error);\n      }\n    },\n    async fetchFreeMemory() {\n      try {\n        const response = await axios.get('/memory/free-size');\n        this.freeMemory = response.data;\n        this.usedMemory = this.totalMemory - this.freeMemory;\n      } catch (error) {\n        console.error('获取空闲内存大小失败:', error);\n      }\n    },\n    updateMemoryBlocks(memoryStatus) {\n      const totalBlocks = Math.ceil(this.totalMemory / this.blockSize);\n      const rows = Math.ceil(totalBlocks / this.blocksPerRow);\n      this.memoryRows = Array(rows).fill().map((_, rowIndex) => Array(this.blocksPerRow).fill().map((_, blockIndex) => {\n        const blockNumber = rowIndex * this.blocksPerRow + blockIndex;\n        const processId = memoryStatus[blockNumber];\n        return {\n          status: processId ? 'ALLOCATED' : 'FREE',\n          processId: processId || null,\n          size: this.blockSize\n        };\n      }));\n    },\n    getBlockTooltip(block) {\n      if (block.status === 'ALLOCATED') {\n        return `进程ID: ${block.processId}\\n大小: ${block.size}MB`;\n      }\n      return '空闲块';\n    },\n    allocateMemory(processId, size) {\n      const blocksNeeded = Math.ceil(size / this.blockSize);\n      let allocatedBlocks = 0;\n      for (let row of this.memoryRows) {\n        for (let block of row) {\n          if (block.status === 'FREE') {\n            block.status = 'ALLOCATED';\n            block.processId = processId;\n            allocatedBlocks++;\n            if (allocatedBlocks === blocksNeeded) {\n              this.usedMemory += size;\n              this.freeMemory -= size;\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    },\n    freeMemory(processId) {\n      let freedSize = 0;\n      for (let row of this.memoryRows) {\n        for (let block of row) {\n          if (block.status === 'ALLOCATED' && block.processId === processId) {\n            block.status = 'FREE';\n            block.processId = null;\n            freedSize += block.size;\n          }\n        }\n      }\n      this.usedMemory -= freedSize;\n      this.freeMemory += freedSize;\n    }\n  }\n};","map":{"version":3,"names":["axios","EventBus","name","data","totalMemory","usedMemory","freeMemory","blockSize","memoryRows","blocksPerRow","computed","memoryUsagePercentage","Math","round","memoryUsageColor","percentage","created","initializeMemory","$on","updateMemoryState","beforeDestroy","$off","methods","fetchMemoryStatus","fetchMemoryUsage","fetchFreeMemory","error","console","response","get","memoryStatus","updateMemoryBlocks","usage","totalBlocks","ceil","rows","Array","fill","map","_","rowIndex","blockIndex","blockNumber","processId","status","size","getBlockTooltip","block","allocateMemory","blocksNeeded","allocatedBlocks","row","freedSize"],"sources":["src/components/MemoryManagement.vue"],"sourcesContent":["<template>\n  <div class=\"memory-management\">\n    <h2>内存管理</h2>\n    <div class=\"memory-info\">\n      <div class=\"info-item\">总内存: {{ totalMemory }}MB</div>\n      <div class=\"info-item\">已用内存: {{ usedMemory }}MB</div>\n      <div class=\"info-item\">空闲内存: {{ freeMemory }}MB</div>\n      <div class=\"memory-usage\">\n        <div class=\"usage-label\">内存利用率: {{ memoryUsagePercentage }}%</div>\n        <el-progress \n          :percentage=\"memoryUsagePercentage\"\n          :color=\"memoryUsageColor\"\n          :stroke-width=\"15\"\n          :show-text=\"false\"\n        ></el-progress>\n      </div>\n    </div>\n    \n    <div class=\"memory-blocks\">\n      <div v-for=\"(row, rowIndex) in memoryRows\" :key=\"rowIndex\" class=\"memory-row\">\n        <div\n          v-for=\"(block, blockIndex) in row\"\n          :key=\"blockIndex\"\n          class=\"memory-block\"\n          :class=\"{\n            'allocated': block.status === 'ALLOCATED',\n            'free': block.status === 'FREE'\n          }\"\n          :title=\"getBlockTooltip(block)\"\n        ></div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport axios from 'axios'\nimport { EventBus } from '@/utils/eventBus'\n\nexport default {\n  name: 'MemoryManagement',\n  data() {\n    return {\n      totalMemory: 1024, // 总内存大小（MB）\n      usedMemory: 0,\n      freeMemory: 1024,\n      blockSize: 4, // 每个块的大小（MB）\n      memoryRows: [],\n      blocksPerRow: 16\n    }\n  },\n  computed: {\n    memoryUsagePercentage() {\n      return Math.round((this.usedMemory / this.totalMemory) * 100)\n    },\n    memoryUsageColor() {\n      const percentage = this.memoryUsagePercentage\n      if (percentage < 60) return '#67C23A'\n      if (percentage < 80) return '#E6A23C'\n      return '#F56C6C'\n    }\n  },\n  created() {\n    this.initializeMemory()\n    // 监听进程状态变化事件\n    EventBus.$on('process-state-changed', this.updateMemoryState)\n  },\n  beforeDestroy() {\n    // 移除事件监听\n    EventBus.$off('process-state-changed', this.updateMemoryState)\n  },\n  methods: {\n    async initializeMemory() {\n      try {\n        await this.fetchMemoryStatus()\n        await this.fetchMemoryUsage()\n        await this.fetchFreeMemory()\n      } catch (error) {\n        console.error('初始化内存数据失败:', error)\n      }\n    },\n    async updateMemoryState() {\n      try {\n        await this.fetchMemoryStatus()\n        await this.fetchMemoryUsage()\n        await this.fetchFreeMemory()\n      } catch (error) {\n        console.error('更新内存状态失败:', error)\n      }\n    },\n    async fetchMemoryStatus() {\n      try {\n        const response = await axios.get('/memory/status')\n        const memoryStatus = response.data\n        this.updateMemoryBlocks(memoryStatus)\n      } catch (error) {\n        console.error('获取内存状态失败:', error)\n      }\n    },\n    async fetchMemoryUsage() {\n      try {\n        const response = await axios.get('/memory/usage')\n        const usage = response.data\n        this.usedMemory = Math.round(this.totalMemory * usage)\n        this.freeMemory = this.totalMemory - this.usedMemory\n      } catch (error) {\n        console.error('获取内存使用率失败:', error)\n      }\n    },\n    async fetchFreeMemory() {\n      try {\n        const response = await axios.get('/memory/free-size')\n        this.freeMemory = response.data\n        this.usedMemory = this.totalMemory - this.freeMemory\n      } catch (error) {\n        console.error('获取空闲内存大小失败:', error)\n      }\n    },\n    updateMemoryBlocks(memoryStatus) {\n      const totalBlocks = Math.ceil(this.totalMemory / this.blockSize)\n      const rows = Math.ceil(totalBlocks / this.blocksPerRow)\n      \n      this.memoryRows = Array(rows).fill().map((_, rowIndex) => \n        Array(this.blocksPerRow).fill().map((_, blockIndex) => {\n          const blockNumber = rowIndex * this.blocksPerRow + blockIndex\n          const processId = memoryStatus[blockNumber]\n          \n          return {\n            status: processId ? 'ALLOCATED' : 'FREE',\n            processId: processId || null,\n            size: this.blockSize\n          }\n        })\n      )\n    },\n    getBlockTooltip(block) {\n      if (block.status === 'ALLOCATED') {\n        return `进程ID: ${block.processId}\\n大小: ${block.size}MB`\n      }\n      return '空闲块'\n    },\n    allocateMemory(processId, size) {\n      const blocksNeeded = Math.ceil(size / this.blockSize)\n      let allocatedBlocks = 0\n      \n      for (let row of this.memoryRows) {\n        for (let block of row) {\n          if (block.status === 'FREE') {\n            block.status = 'ALLOCATED'\n            block.processId = processId\n            allocatedBlocks++\n            \n            if (allocatedBlocks === blocksNeeded) {\n              this.usedMemory += size\n              this.freeMemory -= size\n              return true\n            }\n          }\n        }\n      }\n      return false\n    },\n    freeMemory(processId) {\n      let freedSize = 0\n      \n      for (let row of this.memoryRows) {\n        for (let block of row) {\n          if (block.status === 'ALLOCATED' && block.processId === processId) {\n            block.status = 'FREE'\n            block.processId = null\n            freedSize += block.size\n          }\n        }\n      }\n      \n      this.usedMemory -= freedSize\n      this.freeMemory += freedSize\n    }\n  }\n}\n</script>\n\n<style scoped>\n.memory-management {\n  padding: 20px;\n}\n\n.memory-info {\n  display: flex;\n  align-items: center;\n  gap: 20px;\n  margin-bottom: 20px;\n  flex-wrap: nowrap;\n}\n\n.info-item {\n  white-space: nowrap;\n}\n\n.memory-blocks {\n  border: 1px solid #dcdfe6;\n  padding: 10px;\n  background-color: #f5f7fa;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n.memory-row {\n  display: flex;\n  gap: 2px;\n  margin-bottom: 2px;\n  justify-content: center;\n}\n\n.memory-block {\n  width: 30px;\n  height: 30px;\n  border: 1px solid #dcdfe6;\n  cursor: pointer;\n}\n\n.memory-block.allocated {\n  background-color: #409eff;\n}\n\n.memory-block.free {\n  background-color: #f0f9eb;\n}\n\n.memory-usage {\n  flex: 1;\n  min-width: 200px;\n  margin-left: 20px;\n}\n\n.usage-label {\n  margin-bottom: 5px;\n  font-weight: bold;\n  white-space: nowrap;\n}\n</style> "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}