{"ast":null,"code":"import { getFreeMemoryBlocks, getFreeMemorySize, getMemoryStatus, getMemoryUsage } from '../api/memory';\nimport { getInterruptLogs } from '@/api/interrupt';\nexport default {\n  name: 'MemoryManagement',\n  data() {\n    return {\n      // 内存部分\n      totalMemory: 1024,\n      // 总内存大小（MB）\n      usedMemory: 0,\n      freeMemory: 1024,\n      blockSize: 4,\n      // 每个块的大小（MB）\n      memoryRows: [],\n      blocksPerRow: 16,\n      // 中断部分\n      updateInterval: null,\n      interrupts: [],\n      timer: null\n    };\n  },\n  computed: {\n    memoryUsagePercentage() {\n      return Math.round(this.usedMemory / this.totalMemory * 100);\n    },\n    memoryUsageColor() {\n      const percentage = this.memoryUsagePercentage;\n      if (percentage < 60) return '#67C23A';\n      if (percentage < 80) return '#E6A23C';\n      return '#F56C6C';\n    }\n  },\n  created() {\n    this.initializeMemory();\n    this.fetchMemoryData();\n    // 每1秒更新一次内存数据\n    this.updateInterval = setInterval(this.fetchMemoryData, 1000);\n    // 初始加载中断日志\n    this.fetchInterruptLogs();\n    // 设置定时刷新\n    this.timer = setInterval(() => {\n      this.fetchInterruptLogs();\n    }, 5000); // 每5秒刷新一次\n  },\n  beforeDestroy() {\n    if (this.updateInterval) {\n      clearInterval(this.updateInterval);\n    }\n    // 组件销毁前清除定时器\n    if (this.timer) {\n      clearInterval(this.timer);\n    }\n  },\n  methods: {\n    initializeMemory() {\n      const totalBlocks = Math.ceil(this.totalMemory / this.blockSize);\n      const rows = Math.ceil(totalBlocks / this.blocksPerRow);\n      this.memoryRows = Array(rows).fill().map(() => Array(this.blocksPerRow).fill().map(() => ({\n        status: 'FREE',\n        processId: null,\n        size: this.blockSize\n      })));\n    },\n    getBlockTooltip(block) {\n      if (block.status === 'ALLOCATED') {\n        return `进程ID: ${block.processId}\\n大小: ${block.size}MB`;\n      }\n      return '空闲块';\n    },\n    allocateMemory(processId, size) {\n      const blocksNeeded = Math.ceil(size / this.blockSize);\n      let allocatedBlocks = 0;\n      for (let row of this.memoryRows) {\n        for (let block of row) {\n          if (block.status === 'FREE') {\n            block.status = 'ALLOCATED';\n            block.processId = processId;\n            allocatedBlocks++;\n            if (allocatedBlocks === blocksNeeded) {\n              this.usedMemory += size;\n              this.freeMemory -= size;\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    },\n    releaseMemory(processId) {\n      let freedSize = 0;\n      for (let row of this.memoryRows) {\n        for (let block of row) {\n          if (block.status === 'ALLOCATED' && block.processId === processId) {\n            block.status = 'FREE';\n            block.processId = null;\n            freedSize += block.size;\n          }\n        }\n      }\n      this.usedMemory -= freedSize;\n      this.freeMemory += freedSize;\n    },\n    async fetchMemoryData() {\n      try {\n        // 获取空闲内存大小\n        const freeSize = await getFreeMemorySize();\n        this.freeMemory = freeSize;\n        this.usedMemory = this.totalMemory - freeSize;\n\n        // 获取内存状态\n        const memoryStatus = await getMemoryStatus();\n        this.updateMemoryBlocks(memoryStatus);\n\n        // 获取空闲内存块列表\n        const freeBlocks = await getFreeMemoryBlocks();\n\n        // 获取内存使用率\n        const usage = await getMemoryUsage();\n      } catch (error) {\n        this.$message.error('获取内存数据失败');\n      }\n    },\n    updateMemoryBlocks(memoryStatus) {\n      const totalBlocks = Math.ceil(this.totalMemory / this.blockSize);\n      const rows = Math.ceil(totalBlocks / this.blocksPerRow);\n      this.memoryRows = Array(rows).fill().map((_, rowIndex) => Array(this.blocksPerRow).fill().map((_, blockIndex) => {\n        const index = rowIndex * this.blocksPerRow + blockIndex;\n        const processId = index < memoryStatus.length ? memoryStatus[index] : 0;\n        return {\n          status: processId === 0 ? 'FREE' : 'ALLOCATED',\n          processId: processId === 0 ? null : processId,\n          size: this.blockSize\n        };\n      }));\n    },\n    getInterruptType(type) {\n      const typeMap = {\n        'CLOCK': 'primary',\n        'IO': 'success',\n        'DEVICE': 'warning',\n        'ERROR': 'danger',\n        'PROCESS': 'info'\n      };\n      return typeMap[type] || 'info';\n    },\n    addInterrupt(type, message) {\n      const now = new Date();\n      const time = `${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}`;\n      this.interrupts.unshift({\n        type,\n        message,\n        time\n      });\n    },\n    // 获取中断日志\n    async fetchInterruptLogs() {\n      try {\n        const response = await getInterruptLogs();\n        if (response.status === 'success') {\n          this.interrupts = response.data;\n        }\n      } catch (error) {\n        console.error('获取中断日志失败:', error);\n      }\n    },\n    // 格式化时间戳\n    formatTimestamp(timestamp) {\n      return new Date(timestamp).toLocaleString();\n    }\n  }\n};","map":{"version":3,"names":["getFreeMemoryBlocks","getFreeMemorySize","getMemoryStatus","getMemoryUsage","getInterruptLogs","name","data","totalMemory","usedMemory","freeMemory","blockSize","memoryRows","blocksPerRow","updateInterval","interrupts","timer","computed","memoryUsagePercentage","Math","round","memoryUsageColor","percentage","created","initializeMemory","fetchMemoryData","setInterval","fetchInterruptLogs","beforeDestroy","clearInterval","methods","totalBlocks","ceil","rows","Array","fill","map","status","processId","size","getBlockTooltip","block","allocateMemory","blocksNeeded","allocatedBlocks","row","releaseMemory","freedSize","freeSize","memoryStatus","updateMemoryBlocks","freeBlocks","usage","error","$message","_","rowIndex","blockIndex","index","length","getInterruptType","type","typeMap","addInterrupt","message","now","Date","time","getHours","getMinutes","getSeconds","unshift","response","console","formatTimestamp","timestamp","toLocaleString"],"sources":["src/components/MemoryManagement.vue"],"sourcesContent":["<template>\n  <div class=\"memory-management\">\n    <!-- <h2 style=\"margin: 5px 0;\">内存管理</h2> -->\n    <div class=\"memory-info\">\n      <div class=\"info-item\">总内存: {{ totalMemory }}MB</div>\n      <div class=\"info-item\">已用内存: {{ usedMemory }}MB</div>\n      <div class=\"info-item\">空闲内存: {{ freeMemory }}MB</div>\n      <div class=\"memory-usage\">\n        <div class=\"usage-label\">内存利用率: {{ memoryUsagePercentage }}%</div>\n        <el-progress \n          :percentage=\"memoryUsagePercentage\"\n          :color=\"memoryUsageColor\"\n          :stroke-width=\"15\"\n          :show-text=\"false\"\n        ></el-progress>\n      </div>\n    </div>\n    \n    <div class=\"memory-blocks\">\n      <div v-for=\"(row, rowIndex) in memoryRows\" :key=\"rowIndex\" class=\"memory-row\">\n        <div\n          v-for=\"(block, blockIndex) in row\"\n          :key=\"blockIndex\"\n          class=\"memory-block\"\n          :class=\"{\n            'allocated': block.status === 'ALLOCATED',\n            'free': block.status === 'FREE'\n          }\"\n          :title=\"getBlockTooltip(block)\"\n        ></div>\n      </div>\n    </div>\n\n    <div class=\"interrupt-handling\">\n      <h3>中断处理</h3>\n      <div class=\"interrupt-list\">\n        <el-timeline>\n          <el-timeline-item\n            v-for=\"interrupt in interrupts\"\n            :key=\"interrupt.id\"\n            :type=\"getInterruptType(interrupt.type)\"\n            :timestamp=\"formatTimestamp(interrupt.timestamp)\">\n            <div class=\"interrupt-content\">\n              <div class=\"interrupt-message\">{{ interrupt.message }}</div>\n              <div class=\"interrupt-result\">{{ interrupt.result }}</div>\n            </div>\n          </el-timeline-item>\n        </el-timeline>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { getFreeMemoryBlocks, getFreeMemorySize, getMemoryStatus, getMemoryUsage } from '../api/memory'\nimport { getInterruptLogs } from '@/api/interrupt'\n\nexport default {\n  name: 'MemoryManagement',\n  data() {\n    return {\n      \n      // 内存部分\n      totalMemory: 1024, // 总内存大小（MB）\n      usedMemory: 0,\n      freeMemory: 1024,\n      blockSize: 4, // 每个块的大小（MB）\n      memoryRows: [],\n      blocksPerRow: 16,\n\n      // 中断部分\n      updateInterval: null,\n      interrupts: [],\n      timer: null\n    }\n  },\n  computed: {\n    memoryUsagePercentage() {\n      return Math.round((this.usedMemory / this.totalMemory) * 100)\n    },\n    memoryUsageColor() {\n      const percentage = this.memoryUsagePercentage\n      if (percentage < 60) return '#67C23A'\n      if (percentage < 80) return '#E6A23C'\n      return '#F56C6C'\n    }\n  },\n  created() {\n    this.initializeMemory()\n    this.fetchMemoryData()\n    // 每1秒更新一次内存数据\n    this.updateInterval = setInterval(this.fetchMemoryData, 1000)\n    // 初始加载中断日志\n    this.fetchInterruptLogs()\n    // 设置定时刷新\n    this.timer = setInterval(() => {\n      this.fetchInterruptLogs()\n    }, 5000) // 每5秒刷新一次\n  },\n  beforeDestroy() {\n    if (this.updateInterval) {\n      clearInterval(this.updateInterval)\n    }\n    // 组件销毁前清除定时器\n    if (this.timer) {\n      clearInterval(this.timer)\n    }\n  },\n  methods: {\n\n    initializeMemory() {\n      const totalBlocks = Math.ceil(this.totalMemory / this.blockSize)\n      const rows = Math.ceil(totalBlocks / this.blocksPerRow)\n      \n      this.memoryRows = Array(rows).fill().map(() => \n        Array(this.blocksPerRow).fill().map(() => ({\n          status: 'FREE',\n          processId: null,\n          size: this.blockSize\n        }))\n      )\n    },\n    getBlockTooltip(block) {\n      if (block.status === 'ALLOCATED') {\n        return `进程ID: ${block.processId}\\n大小: ${block.size}MB`\n      }\n      return '空闲块'\n    },\n    allocateMemory(processId, size) {\n      const blocksNeeded = Math.ceil(size / this.blockSize)\n      let allocatedBlocks = 0\n      \n      for (let row of this.memoryRows) {\n        for (let block of row) {\n          if (block.status === 'FREE') {\n            block.status = 'ALLOCATED'\n            block.processId = processId\n            allocatedBlocks++\n            \n            if (allocatedBlocks === blocksNeeded) {\n              this.usedMemory += size\n              this.freeMemory -= size\n              return true\n            }\n          }\n        }\n      }\n      return false\n    },\n    releaseMemory(processId) {\n      let freedSize = 0\n      \n      for (let row of this.memoryRows) {\n        for (let block of row) {\n          if (block.status === 'ALLOCATED' && block.processId === processId) {\n            block.status = 'FREE'\n            block.processId = null\n            freedSize += block.size\n          }\n        }\n      }\n      \n      this.usedMemory -= freedSize\n      this.freeMemory += freedSize\n    },\n    async fetchMemoryData() {\n      try {\n        // 获取空闲内存大小\n        const freeSize = await getFreeMemorySize()\n        this.freeMemory = freeSize\n        this.usedMemory = this.totalMemory - freeSize\n\n        // 获取内存状态\n        const memoryStatus = await getMemoryStatus()\n        this.updateMemoryBlocks(memoryStatus)\n\n        // 获取空闲内存块列表\n        const freeBlocks = await getFreeMemoryBlocks()\n\n        // 获取内存使用率\n        const usage = await getMemoryUsage()\n      } catch (error) {\n        this.$message.error('获取内存数据失败')\n      }\n    },\n    updateMemoryBlocks(memoryStatus) {\n      const totalBlocks = Math.ceil(this.totalMemory / this.blockSize)\n      const rows = Math.ceil(totalBlocks / this.blocksPerRow)\n      \n      this.memoryRows = Array(rows).fill().map((_, rowIndex) => \n        Array(this.blocksPerRow).fill().map((_, blockIndex) => {\n          const index = rowIndex * this.blocksPerRow + blockIndex\n          const processId = index < memoryStatus.length ? memoryStatus[index] : 0\n          return {\n            status: processId === 0 ? 'FREE' : 'ALLOCATED',\n            processId: processId === 0 ? null : processId,\n            size: this.blockSize\n          }\n        })\n      )\n    },\n    getInterruptType(type) {\n      const typeMap = {\n        'CLOCK': 'primary',\n        'IO': 'success',\n        'DEVICE': 'warning',\n        'ERROR': 'danger',\n        'PROCESS': 'info'\n      }\n      return typeMap[type] || 'info'\n    },\n    addInterrupt(type, message) {\n      const now = new Date()\n      const time = `${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}`\n      this.interrupts.unshift({\n        type,\n        message,\n        time\n      })\n    },\n    // 获取中断日志\n    async fetchInterruptLogs() {\n      try {\n        const response = await getInterruptLogs()\n        if (response.status === 'success') {\n          this.interrupts = response.data\n        }\n      } catch (error) {\n        console.error('获取中断日志失败:', error)\n      }\n    },\n    // 格式化时间戳\n    formatTimestamp(timestamp) {\n      return new Date(timestamp).toLocaleString()\n    }\n  }\n}\n</script>\n\n<style scoped>\n.memory-management {\n  padding: 10px;\n}\n\n.memory-info {\n  display: flex;\n  align-items: center;\n  gap: 20px;\n  margin-bottom: 10px;\n  flex-wrap: nowrap;\n}\n\n.info-item {\n  white-space: nowrap;\n}\n\n.memory-blocks {\n  border: 1px solid #dcdfe6;\n  padding: 8px;\n  background-color: #f5f7fa;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n.memory-row {\n  display: flex;\n  gap: 1px;\n  margin-bottom: 1px;\n  justify-content: center;\n}\n\n.memory-block {\n  width: 20px;\n  height: 20px;\n  border: 1px solid #dcdfe6;\n  cursor: pointer;\n}\n\n.memory-block.allocated {\n  background-color: #409eff;\n}\n\n.memory-block.free {\n  background-color: #f0f9eb;\n}\n\n.memory-usage {\n  flex: 1;\n  min-width: 200px;\n  margin-left: 20px;\n}\n\n.usage-label {\n  margin-bottom: 5px;\n  font-weight: bold;\n  white-space: nowrap;\n}\n\n.interrupt-handling {\n  margin-top: 20px;\n  padding: 20px;\n  background-color: #fff;\n  border-radius: 4px;\n  box-shadow: 0 2px 12px 0 rgba(0,0,0,0.1);\n  height: 250px;\n}\n\n.interrupt-handling h3 {\n  margin: 0 0 10px 0;\n  font-size: 16px;\n  flex-shrink: 0;\n}\n\n.interrupt-list {\n  margin-top: 15px;\n  max-height: 200px;\n  overflow-y: auto;\n}\n\n.interrupt-content {\n  display: flex;\n  flex-direction: column;\n  gap: 5px;\n}\n\n.interrupt-message {\n  font-weight: 500;\n  color: #303133;\n}\n\n.interrupt-result {\n  color: #606266;\n  font-size: 0.9em;\n}\n</style> "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}